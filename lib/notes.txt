// code example for linked list struct to serialized json format to send to azure iot hub
void serializeLinkedListToJson(const DataNode* head, JsonDocument& doc) {
    // Create a JSON array at the root of the document.
    // Each element of this array will be a JSON object representing a DataNode.
    JsonArray mainArray = doc.to<JsonArray>();

    const DataNode* currentNode = head;
    while (currentNode != nullptr) {
        // Create a nested JSON object for the current DataNode
        JsonObject nodeObject = mainArray.createNestedObject();

        // Add scalar values directly
        nodeObject["temperature"] = currentNode->temperature;
        nodeObject["bpm"] = currentNode->beat_per_minute; // Using "bpm" as a shorter key
        nodeObject["spo2"] = currentNode->spo2;

        // Serialize the acceleration_x_arr
        if (currentNode->acceleration_x_arr != nullptr && currentNode->acceleration_x_size > 0) {
            JsonArray axArray = nodeObject.createNestedArray("accel_x");
            for (int i = 0; i < currentNode->acceleration_x_size; ++i) {
                axArray.add(currentNode->acceleration_x_arr[i]);
            }
        } else {
            // Optionally add a null or empty array if the source array is null or empty
            nodeObject["accel_x"] = JsonArray(); // or nodeObject["accel_x"] = nullptr;
        }

        // Serialize the acceleration_y_arr
        if (currentNode->acceleration_y_arr != nullptr && currentNode->acceleration_y_size > 0) {
            JsonArray ayArray = nodeObject.createNestedArray("accel_y");
            for (int i = 0; i < currentNode->acceleration_y_size; ++i) {
                ayArray.add(currentNode->acceleration_y_arr[i]);
            }
        } else {
            nodeObject["accel_y"] = JsonArray(); // or nodeObject["accel_y"] = nullptr;
        }

        // Add serialization for accel_z if you have it, following the same pattern.

        // Move to the next node in the linked list
        currentNode = currentNode->next;
    }
}








///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
//
// code example for connecting to mqtt azure, light sleep mode, serialization(substitute with the above function), and sending telemetry data
//
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <stdlib.h> // For malloc/calloc/free if you were using it for arrays

// --- Light Sleep Configuration ---
#define uS_TO_S_FACTOR 1000000ULL // Conversion factor for micro seconds to seconds
#define TIME_TO_SLEEP_S 30       // Time ESP32 will go to light sleep (in seconds)

// --- WiFi Configuration ---
const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";

// --- Azure IoT Hub Configuration ---
const char* iotHubHost = "YOUR_IOT_HUB.azure-devices.net";
const char* deviceId = "YOUR_DEVICE_ID";
const char* sasToken = "PASTE_YOUR_DEVICE_SAS_TOKEN_HERE"; // Ensure this is valid

// --- MQTT Configuration ---
const int mqttPort = 8883; // TLS
char telemetryTopic[100];

WiFiClientSecure wifiClientSecure;
PubSubClient mqttClient(wifiClientSecure);

// --- Global Data Variables (Example) ---
float currentTemperature;
int operationalMode;
float sensorReadingsArray[5]; // Static array for simplicity
int numReadingsInArray;

// Function to "collect" or prepare sensor data
void prepareSensorData() {
    Serial.println("Preparing sensor data...");
    currentTemperature = 20.0 + (esp_random() % 100) / 10.0;
    operationalMode = (esp_random() % 3) + 1;

    numReadingsInArray = sizeof(sensorReadingsArray) / sizeof(sensorReadingsArray[0]);
    for (int i = 0; i < numReadingsInArray; i++) {
        sensorReadingsArray[i] = 50.0 + (esp_random() % 500) / 10.0;
    }
    Serial.println("Sensor data prepared.");
}

// Function to format data into JSON
// Returns true on success, false on failure
bool formatDataToJson(char* outBuffer, size_t bufferSize) {
    StaticJsonDocument<300> doc; // Adjust size as needed

    doc["deviceId"] = deviceId;
    doc["temperature"] = currentTemperature;
    doc["mode"] = operationalMode;
    doc["uptimeMillisSinceBoot"] = millis(); // Uptime since boot, as millis() continues across light sleep

    JsonArray data_readings = doc.createNestedArray("sensorArray");
    for (int i = 0; i < numReadingsInArray; i++) {
        data_readings.add(sensorReadingsArray[i]);
    }

    size_t n = serializeJson(doc, outBuffer, bufferSize);
    if (n == 0 || n >= bufferSize) {
        Serial.println(F("Failed to serialize JSON or buffer too small."));
        return false;
    }
    Serial.print(F("JSON Payload: "));
    Serial.println(outBuffer);
    return true;
}

// Function to connect to WiFi with retry
bool connectWifi() {
    // Check if already connected (can happen if sleep was very short or WiFi somehow persisted)
    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("Already connected to WiFi.");
        return true;
    }

    int connectTimeoutSeconds = 30;
    int attempt = 0;
    const int maxAttempts = connectTimeoutSeconds * 2;

    Serial.print("Connecting to WiFi: ");
    Serial.println(ssid);
    WiFi.mode(WIFI_STA); // Ensure STA mode
    WiFi.begin(ssid, password);

    while (WiFi.status() != WL_CONNECTED) {
        attempt++;
        delay(500);
        Serial.print(".");
        if (attempt >= maxAttempts) {
            Serial.println("\nFailed to connect to WiFi after multiple attempts.");
            WiFi.disconnect(true); // Explicitly disconnect
            // WiFi.mode(WIFI_OFF); // Optional: turn off WiFi module to save a bit more
            return false;
        }
    }
    Serial.println("\nWiFi connected!");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
    return true;
}

// Function to connect to MQTT
bool connectMqtt() {
    // Check if already connected
    if (mqttClient.connected()){
        Serial.println("Already connected to MQTT.");
        return true;
    }
    mqttClient.setServer(iotHubHost, mqttPort);

    int retryAttempts = 3;
    while (!mqttClient.connected() && retryAttempts > 0) {
        Serial.print("Attempting MQTT connection (Azure IoT Hub)... ");
        char mqttUsername[200];
        snprintf(mqttUsername, sizeof(mqttUsername), "%s/%s/?api-version=2021-04-12", iotHubHost, deviceId);

        if (mqttClient.connect(deviceId, mqttUsername, sasToken)) {
            Serial.println("connected!");
            return true;
        } else {
            Serial.print("failed, rc=");
            Serial.print(mqttClient.state());
            char wifiSecureErrorBuffer[200];
            wifiClientSecure.lastError(wifiSecureErrorBuffer, 200);
            Serial.print(", WiFiClientSecure Error: ");
            Serial.println(wifiSecureErrorBuffer);

            retryAttempts--;
            if (retryAttempts > 0) {
                Serial.println("Retrying in 3 seconds...");
                delay(3000);
            }
        }
    }
    Serial.println("Failed to connect to MQTT after multiple attempts.");
    return false;
}

// Function to send telemetry data
bool sendTelemetryData(const char*jsonData) {
    if (!mqttClient.connected()) {
        Serial.println("MQTT not connected. Cannot send telemetry.");
        return false;
    }
    snprintf(telemetryTopic, sizeof(telemetryTopic), "devices/%s/messages/events/", deviceId);
    Serial.print("Publishing to topic: ");
    Serial.println(telemetryTopic);

    if (mqttClient.publish(telemetryTopic, jsonData)) {
        Serial.println("Telemetry message published successfully.");
        return true;
    } else {
        Serial.println("Failed to publish telemetry message.");
        return false;
    }
}

void goToLightSleep() {
    Serial.println("Entering light sleep for " + String(TIME_TO_SLEEP_S) + " seconds.");
    Serial.flush(); // Ensure all serial output is sent

    // Configure timer wake-up for light sleep
    esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP_S * uS_TO_S_FACTOR);
    esp_light_sleep_start();
    // Execution resumes here after light sleep
    Serial.println("Woke up from light sleep.");
}

void setup() {
    Serial.begin(115200);
    delay(1000);
    Serial.println("\nESP32 Azure IoT Light Sleep Demo");
    Serial.println("------------------------------------");

    // Initial WiFi setup (optional, as connectWifi will handle it)
    // WiFi.mode(WIFI_STA);
    // WiFi.disconnect(true); // Start fresh

    // You might do one-time initializations here
}

void loop() {
    Serial.println("\n--- Starting new cycle ---");

    prepareSensorData();

    char jsonPayload[350]; // Ensure this buffer is large enough
    if (!formatDataToJson(jsonPayload, sizeof(jsonPayload))) {
        Serial.println("Could not format data to JSON. Skipping cycle.");
        goToLightSleep();
        return;
    }

    if (!connectWifi()) {
        Serial.println("WiFi connection failed for this cycle.");
        // connectWifi() already paused and retried. If it fails, we sleep and try next cycle.
        goToLightSleep();
        return;
    }

    // WiFi is connected, now try MQTT
    if (!connectMqtt()) {
        Serial.println("MQTT connection failed for this cycle.");
        // Disconnect WiFi before sleeping if MQTT failed
        WiFi.disconnect(true);
        // WiFi.mode(WIFI_OFF); // Optional
        goToLightSleep();
        return;
    }

    // MQTT is connected, send data
    if (sendTelemetryData(jsonPayload)) {
        Serial.println("Telemetry sent successfully for this cycle!");
    } else {
        Serial.println("Failed to send telemetry for this cycle.");
    }

    // Disconnect MQTT and WiFi gracefully before light sleep
    // This is good practice to free resources and ensure clean state for next wake
    Serial.println("Disconnecting services before light sleep...");
    mqttClient.disconnect();
    WiFi.disconnect(true);
    // WiFi.mode(WIFI_OFF); // Optional: Can slightly reduce power during sleep if RF part is fully off

    goToLightSleep();
}



operating for 3 months
less than 35mAh per day
less than 1.45mAh per hour


