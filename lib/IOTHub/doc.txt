**Key Points and How to Use:**

1.  **Configuration:**
    * Fill in `WIFI_SSID`, `WIFI_PASSWORD`.
    * **Crucially, set `IOTHUB_CONNECTION_STRING`**. This is the primary connection string for your device from the Azure portal.
    * **`AZURE_IOT_ROOT_CA`**: You **must** define this constant with the correct PEM-formatted root CA certificate string for Azure IoT Hub. Without it, the TLS connection will fail. The code includes a strong warning if it detects the placeholder.
    * `MQTT_KEEP_ALIVE_MINUTES` is set to 20. The SDK will handle sending MQTT PINGs.

2.  **`setupWiFi()` and `syncTimeNTP()`:** These are similar to the previous version, ensuring network connectivity and correct time for TLS.

3.  **`setupAzureIoTClient()`:**
    * Initializes the underlying platform (a step required by some SDK wrappers).
    * Creates an `IOTHUB_CLIENT_LL_HANDLE` using your connection string and specifies MQTT as the protocol.
    * **Sets the trusted CA certificate option** using `IoTHubClient_LL_SetOption(iotHubClientHandle, OPTION_TRUSTED_CERT, AZURE_IOT_ROOT_CA)`.
    * Sets the keep-alive option.
    * Sets a `connectionStatusCallback` which updates the `iotHubConnected` flag.
    * Optionally, you can set a message callback for C2D messages (commented out).

4.  **`sendJsonToAzure(const char* jsonPayload)`:**
    * Checks if the client is initialized and connected.
    * Creates an `IOTHUB_MESSAGE_HANDLE` from your JSON string.
    * Sends the event asynchronously using `IoTHubClient_LL_SendEventAsync`.
    * A `sendConfirmationCallback` is provided to know if the message was successfully acknowledged by the hub. **Important:** The message handle is destroyed in this callback to free resources.

5.  **`isAzureIoTConnected()`:**
    * Returns the state of the `iotHubConnected` boolean flag, which is managed by the `connectionStatusCallback`.

6.  **Callbacks:**
    * `connectionStatusCallback`: Called by the SDK when the connection status changes. It updates `iotHubConnected`.
    * `sendConfirmationCallback`: Called after a telemetry message send attempt. You **must destroy the message handle** here (`IoTHubMessage_Destroy`).

7.  **`setup()` function:**
    * Initializes Serial.
    * Calls `setupAzureIoTClient()`.

8.  **`loop()` function:**
    * **`IoTHubClient_LL_DoWork(iotHubClientHandle);`**: This is **THE MOST IMPORTANT** part of using the Azure C SDK's LL (Lower Layer) APIs. You **must** call this function frequently in your main loop. It handles all network communication, including sending queued messages, receiving data, processing acknowledgments, and managing the MQTT keep-alive pings. If you don't call this, your device won't communicate.
    * The example includes sending telemetry periodically.
    * A small `delay(100)` is added. Adjust this based on your application's needs, ensuring `DoWork` is called often enough (typically multiple times per second if possible, or at least every few seconds).

**To Make This Work:**

1.  Replace all `YOUR_...` placeholders.
2.  Paste your actual Azure IoT Hub Root CA certificate string into the `AZURE_IOT_ROOT_CA` definition.
3.  Compile and upload to your ESP32.

This SDK-based approach is generally more robust for production applications as it's maintained by Microsoft and handles more edge cases and features of Azure IoT Hub than a manual MQTT implementati